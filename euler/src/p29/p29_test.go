/****
Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
****/

package main

import (
	"reflect"
	"testing"
)

type slice_int []int

func Test_xPowY(t *testing.T) {
	type args struct {
		x int
		y int
	}
	tests := []struct {
		name string
		args args
		want []int
	}{
		// TODO: Add test cases.
		{"1^2", args{1, 2}, slice_int{1}},
		{"", args{2, 2}, slice_int{4}},
		{"", args{2, 3}, slice_int{8}},
		{"", args{2, 10}, slice_int{4, 2, 0, 1}},
		{"", args{3, 5}, slice_int{3, 4, 2}},
		{"", args{10, 5}, slice_int{0, 0, 0, 0, 0, 1}},
		{"", args{177, 3}, slice_int{3, 3, 2, 5, 4, 5, 5}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := xPowY(tt.args.x, tt.args.y); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("xPowY() = %v, want %v", got, tt.want)
			}
		})
	}
}
