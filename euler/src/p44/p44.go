/***

Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?


***/

/**

Analysis: assume k>j, P(k)-P(j) will be j(3j-1),
D(j) = j(3j - 1) will be smallest between 0 and 1/3 but j should be integer
And
D(0) < D(1) < D(n>1)
D(0) < D(-1) < D(n<-1)

but i is [1,2,3,...]
so the smallest j that meets the above criterea will yield the smallest D

difficulty is how to find this J and K, when to stop? because you don't know if you will get one? and when to give up?

**/

/**
let the index be I[1,2,3,4..]
and observe that
P[2] = P[1] + 3*1 + 1
P[3] = P[2] + 3*2 + 1
P[4] = P[3] + 3*3 + 1

P[n+1] = P[n] + 3*n + 1
the gap between P[n] and P[n+1] is 3n+1

let P[j] with some j, P[k] with some k, if 3k+1 > P[j], then this searching sequence can stop, because it won't make P[k]+P[j] a pentagonal


***/

package main

import (
	"fmt"

	"github.com/kangxie-colorado/golang-primer/euler/libs"
)

var p = []int{1, 5, 12, 22, 35, 51, 70, 92, 117, 145}

func findJandK() {
	for j := 0; ; j++ {
		for k := j + 1; ; k++ {
			// we use base-0 index, but in above analysis the base is 1
			// easiest way to offset this is to use k+1 to gauge the next gap size
			if 3*(k+1)+1 > p[j] {
				break
			}

			// we need to grow the slice until it can accomondate P[k]+P[j]
			for p[k]+p[j] > p[len(p)-1] {
				nextN := len(p) + 1
				p = append(p, nextN*(3*nextN-1)/2)
			}

			if libs.IsNumInSlice(p[k]+p[j], p) {
				if libs.IsNumInSlice(p[k]-p[j], p) {
					fmt.Println(j, p[j], k, p[k], p[k]-p[j])
					return
				}
			}
		}
	}
}

func main() {
	findJandK()
}
